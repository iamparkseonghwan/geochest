<!doctype html>
<html lang="ko">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>사물함 티켓팅</title>
	<style>
		:root{--available:#f3f4f6;--held:#fde68a;--sold:#86efac;--border:#e5e7eb}
		body{font-family:Inter,system-ui,Apple SD Gothic Neo,AppleGothic,"맑은 고딕",sans-serif;margin:0;background:#fafafa;color:#111}
		header{display:flex;align-items:center;justify-content:space-between;padding:16px;background:#fff;border-bottom:1px solid var(--border)}
		h1{font-size:18px;margin:0}
		.controls{display:flex;gap:8px;align-items:center}
		input[type=text]{padding:8px;border:1px solid var(--border);border-radius:6px}
		button{padding:8px 12px;border-radius:6px;border:1px solid var(--border);background:#fff;cursor:pointer}
		main{padding:16px}
		.info{display:flex;gap:12px;margin-bottom:12px;align-items:center}
		.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(70px,1fr));gap:8px}
		.locker{border:1px solid var(--border);padding:10px;border-radius:8px;text-align:center;cursor:pointer;user-select:none}
		.locker .num{font-weight:700;margin-bottom:6px}
		.status{font-size:12px;color:#374151}
		.available{background:var(--available)}
		.held{background:linear-gradient(90deg,var(--held),#fff)}
		.sold{background:linear-gradient(90deg,var(--sold),#fff)}
		.tiny{font-size:11px;color:#6b7280}
		#modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.4)}
		#modal .card{background:#fff;padding:18px;border-radius:8px;min-width:320px}
		footer{padding:12px;text-align:center;font-size:13px;color:#6b7280}
		@media (max-width:420px){.grid{grid-template-columns:repeat(3,1fr)}}
	</style>
</head>
<body>
<header>
	<h1>사물함 티켓팅</h1>
	<div class="controls">
		<label class="tiny">이름</label>
		<input id="username" type="text" placeholder="이름을 입력하세요" />
		<label class="tiny">수량</label>
		<select id="quantity"><option>1</option><option>2</option><option>3</option><option>4</option><option>5</option></select>
		<button id="findBest">연속 찾기</button>
		<button id="adminBtn">관리자</button>
	</div>
</header>

<main>
	<div class="info">
		<div class="tiny">클릭하면 보유(예약)됩니다. 보유 시간 내 구매하세요.</div>
		<div id="stats" class="tiny"></div>
	</div>
	<div id="grid" class="grid"></div>
</main>

<div id="modal">
	<div class="card">
		<h3 id="modalTitle">구매 확인</h3>
		<div id="modalBody"></div>
		<div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
			<button id="modalCancel">취소</button>
			<button id="modalConfirm">구매하기</button>
		</div>
	</div>
</div>

<div id="adminPanel" style="display:none;position:fixed;inset:0;align-items:center;justify-content:center;background:rgba(0,0,0,0.45)">
	<div class="card" style="min-width:360px;padding:16px">
		<h3>관리자 편집</h3>
		<div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">
			<input id="adminLockerId" type="hidden" />
			<label class="tiny">사물함 상태</label>
			<select id="adminStatus"><option value="available">available</option><option value="held">held</option><option value="sold">sold</option></select>
			<label class="tiny">소유자 (빈칸이면 없음)</label>
			<input id="adminOwner" type="text" placeholder="이름" />
			<label class="tiny">보유 시간(초, held일 때만 적용)</label>
			<input id="adminHoldSec" type="number" min="1" placeholder="예: 30" />
		</div>
		<div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
			<button id="adminCancel">취소</button>
			<button id="adminResetAction">초기화</button>
			<button id="adminSave">저장</button>
		</div>
	</div>
</div>

<footer>좌석 상태는 서버를 통해 여러 기기에서 공유됩니다.</footer>

<script>
	// 서버 기반 사물함 티켓팅 (여러 기기 동기화용)
	const API_BASE = '/api/lockers';
	const HOLD_MS = 30_000; // 30초 보유 (백엔드와 동일하게 맞춰두기)

	let lockers = [];          // { id, status: 'available'|'held'|'sold', owner, holdExpires }
	let username = '';
	let isAdmin = false;
	const ADMIN_PASSWORD = 'admin123';

	// DTO -> 프론트 모델 변환
	function mapFromDto(d) {
		return {
			id: d.id,
			status: (d.status || 'AVAILABLE').toLowerCase(),
			owner: d.owner || null,
			holdExpires: d.holdExpiresAt || null
		};
	}

	// 서버에서 현재 상태 불러오기
	async function loadState() {
		try {
			const res = await fetch(API_BASE);
			if (!res.ok) {
				console.error('서버에서 좌석 정보를 가져오지 못했습니다.');
				return;
			}
			const data = await res.json();
			lockers = data.map(mapFromDto);
			renderLockers();
			updateStats();
		} catch (e) {
			console.error('loadState 오류', e);
		}
	}

	function renderLockers() {
		const grid = document.getElementById('grid');
		grid.innerHTML = '';
		for (let l of lockers) {
			const el = document.createElement('div');
			el.className = `locker ${l.status}`;
			el.dataset.id = l.id;
			el.innerHTML = `<div class="num">#${l.id}</div><div class="status">${statusText(l)}</div>`;
			el.addEventListener('click', () => onLockerClick(l.id));
			grid.appendChild(el);
		}
		updateStats();
	}

	function statusText(l) {
		if (l.status === 'available') return '사용 가능';
		if (l.status === 'sold') return `구매됨 (${l.owner || '—'})`;
		if (l.status === 'held') {
			const sec = remainingSeconds(l);
			return `보유 중 (${l.owner || '—'}) ${sec}s`;
		}
		return '';
	}

	function remainingSeconds(l) {
		if (!l.holdExpires) return 0;
		const sec = Math.max(0, Math.ceil((l.holdExpires - Date.now()) / 1000));
		return sec;
	}

	// 1초마다 카운트다운 텍스트만 갱신
	function tick() {
		document.querySelectorAll('.locker').forEach(el => {
			const id = +el.dataset.id;
			const l = lockers.find(x => x.id === id);
			if (!l) return;
			const s = el.querySelector('.status');
			if (!s) return;
			if (l.status === 'held' && l.holdExpires) {
				const sec = remainingSeconds(l);
				s.textContent = `보유 중 (${l.owner || '—'}) ${sec}s`;
			} else {
				s.textContent = statusText(l);
			}
		});
	}

	function updateStats() {
		const total = lockers.length;
		const sold = lockers.filter(l => l.status === 'sold').length;
		const held = lockers.filter(l => l.status === 'held').length;
		document.getElementById('stats').textContent =
			`총 ${total}개 · 판매 ${sold} · 보유 ${held}`;
	}

	// 현재 사용자가 유효한 보유를 가지고 있는지 확인
	function userHasActiveHold(name) {
		if (!name) return null;
		const now = Date.now();
		return lockers.find(l =>
			l.status === 'held' &&
			l.owner === name &&
			l.holdExpires &&
			l.holdExpires > now
		) || null;
	}

	// 서버에 hold 요청
	async function holdLocker(id) {
		try {
			const res = await fetch(`${API_BASE}/${id}/hold`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ owner: username })
			});
			if (!res.ok) {
				const msg = await res.json();
				alert(msg || '보유에 실패했습니다.');
				return;
			}
			const d = await res.json();
			const mapped = mapFromDto(d);
			replaceLocker(mapped);
		} catch (e) {
			console.error('holdLocker 오류', e);
			alert('보유 중 오류가 발생했습니다.');
		}
	}

	// 서버에 buy 요청
	async function buyLocker(id) {
		try {
			const res = await fetch(`${API_BASE}/${id}/buy`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ owner: username })
			});
			if (!res.ok) {
				const msg = await res.json();
				alert(msg || '구매에 실패했습니다.');
				return;
			}
			const d = await res.json();
			const mapped = mapFromDto(d);
			replaceLocker(mapped);
		} catch (e) {
			console.error('buyLocker 오류', e);
			alert('구매 중 오류가 발생했습니다.');
		}
	}

	function replaceLocker(updated) {
		const idx = lockers.findIndex(l => l.id === updated.id);
		if (idx !== -1) lockers[idx] = updated;
		else lockers.push(updated);
		renderLockers();
		updateStats();
	}

	// 사물함 클릭 처리
	async function onLockerClick(id) {
		// 관리자 모드면 편집 패널 열기
		if (isAdmin) {
			showAdminPanel(id);
			return;
		}

		username = document.getElementById('username').value.trim();
		if (!username) {
			alert('먼저 이름을 입력하세요.');
			return;
		}

		const l = lockers.find(x => x.id === id);
		if (!l) return;

		const existing = userHasActiveHold(username);

		if (l.status === 'available') {
			if (existing) {
				alert('한 사람당 최대 1개만 보유할 수 있습니다.');
				return;
			}
			await holdLocker(id);
		} else if (l.status === 'held') {
			if (l.owner === username) {
				showModal([l.id]);
			} else {
				alert(`이미 ${l.owner}님이 보유 중입니다.`);
			}
		} else if (l.status === 'sold') {
			alert(`이미 구매된 사물함입니다. (${l.owner || '—'})`);
		}
	}

	function showModal(ids) {
		const modal = document.getElementById('modal');
		document.getElementById('modalBody').textContent =
			`구매할 사물함: ${ids.join(', ')}\n구매를 진행하시겠습니까?`;
		modal.style.display = 'flex';
		modal.dataset.ids = JSON.stringify(ids);
	}

	function hideModal() {
		const modal = document.getElementById('modal');
		modal.style.display = 'none';
		modal.dataset.ids = '';
	}

	async function onModalConfirm() {
		const modal = document.getElementById('modal');
		const ids = JSON.parse(modal.dataset.ids || '[]');
		username = document.getElementById('username').value.trim();
		if (!username) {
			alert('이름을 입력하세요.');
			return;
		}
		for (let id of ids) {
			await buyLocker(id);
		}
		hideModal();
		// 안전하게 전체 상태 재조회
		await loadState();
	}

	// 연속 좌석 찾기 (간단 버전: 첫 available 하나 잡기)
	async function onFindBest() {
		username = document.getElementById('username').value.trim();
		if (!username) {
			alert('이름을 입력하세요.');
			return;
		}
		let qty = parseInt(document.getElementById('quantity').value, 10);
		const existing = userHasActiveHold(username);
		if (existing) {
			alert('이미 보유중입니다 — 한 사람당 최대 1개만 보유할 수 있습니다.');
			return;
		}
		if (qty > 1) {
			alert('한 사람당 최대 1개만 보유할 수 있으므로 수량을 1로 제한합니다.');
			qty = 1;
		}

		const availableLockers = lockers.filter(l => l.status === 'available');
		if (availableLockers.length === 0) {
			alert('사용 가능한 사물함이 없습니다.');
			return;
		}
		const target = availableLockers[0]; // 제일 앞 좌석 하나
		await holdLocker(target.id);
		showModal([target.id]);
	}

	// 관리자 버튼
	function onAdminBtn() {
		const pass = prompt('관리자 비밀번호를 입력하세요');
		if (pass === ADMIN_PASSWORD) {
			isAdmin = true;
			alert('관리자 모드 활성화되었습니다. 사물함을 클릭해 편집 패널을 열 수 있습니다.');
		} else {
			alert('비밀번호가 올바르지 않습니다.');
		}
	}

	function showAdminPanel(id) {
		document.getElementById('adminPanel').style.display = 'flex';
		document.getElementById('adminLockerId').value = id;
		const l = lockers.find(x => x.id === id);
		if (!l) return;
		document.getElementById('adminStatus').value = l.status;
		document.getElementById('adminOwner').value = l.owner || '';
		if (l.holdExpires) {
			document.getElementById('adminHoldSec').value =
				Math.max(1, Math.ceil((l.holdExpires - Date.now()) / 1000));
		} else {
			document.getElementById('adminHoldSec').value = '';
		}
	}

	function hideAdminPanel() {
		document.getElementById('adminPanel').style.display = 'none';
	}

	// 개별 저장은 아직 서버에 반영하지 않음 (UI만)
	function onAdminSave() {
		alert('서버 연동 버전에서는 개별 편집은 아직 지원하지 않습니다.\n초기화 버튼만 사용 가능합니다.');
	}

	// 전체 초기화는 서버에 반영
	async function onAdminResetAction() {
		if (!confirm('관리자: 사물함 상태를 초기화 하시겠습니까?')) return;
		try {
			const res = await fetch(`${API_BASE}/reset`, { method: 'POST' });
			if (!res.ok) {
				const msg = await res.json();
				alert(msg || '초기화에 실패했습니다.');
				return;
			}
			await loadState();
			hideAdminPanel();
			alert('초기화 완료');
		} catch (e) {
			console.error('reset 오류', e);
			alert('초기화 중 오류가 발생했습니다.');
		}
	}

	function init() {
		// username localStorage에서 복원
		const savedName = localStorage.getItem('locker_username');
		if (savedName) {
			document.getElementById('username').value = savedName;
			username = savedName;
		}

		document.getElementById('username').addEventListener('change', e => {
			localStorage.setItem('locker_username', e.target.value);
			username = e.target.value.trim();
		});
		document.getElementById('findBest').addEventListener('click', onFindBest);
		document.getElementById('adminBtn').addEventListener('click', onAdminBtn);
		document.getElementById('modalCancel').addEventListener('click', () => hideModal());
		document.getElementById('modalConfirm').addEventListener('click', onModalConfirm);
		document.getElementById('adminCancel').addEventListener('click', () => hideAdminPanel());
		document.getElementById('adminSave').addEventListener('click', onAdminSave);
		document.getElementById('adminResetAction').addEventListener('click', onAdminResetAction);

		// 최초 1회 서버 상태 로드
		loadState();

		// 3초마다 서버에서 상태를 다시 읽어서(폴링) 다른 기기 변경 사항 반영
		setInterval(loadState, 3000);

		// 1초마다 카운트다운 텍스트만 갱신
		setInterval(tick, 1000);
	}

	document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
